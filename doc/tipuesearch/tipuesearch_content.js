var tipuesearch = {"pages":[{"title":" Rosseland Clouds ","text":"Rosseland Clouds Rosseland Clouds\nThis documentation is in development and used FORD. Developer Info Dr. Elspeth K.H.  Lee","tags":"home","loc":"index.html"},{"title":"Spectral_single – Rosseland Clouds","text":"subroutine Spectral_single(sp, r_med) Uses lxmie_mod Rosseland_data_mod Arguments Type Intent Optional Attributes Name character(len=100), intent(in) :: sp real(kind=dp), intent(in) :: r_med","tags":"","loc":"proc/spectral_single.html"},{"title":"Rosseland_single – Rosseland Clouds","text":"subroutine Rosseland_single(sp) Uses lxmie_mod Rosseland_data_mod allocate end Rosseland mean arrays\nNow calculate ssa and g Arguments Type Intent Optional Attributes Name character(len=100), intent(in) :: sp","tags":"","loc":"proc/rosseland_single.html"},{"title":"Planck_single – Rosseland Clouds","text":"subroutine Planck_single(sp) Uses lxmie_mod Rosseland_data_mod allocate end Planck mean arrays\nNow calculate ssa and g Arguments Type Intent Optional Attributes Name character(len=100), intent(in) :: sp","tags":"","loc":"proc/planck_single.html"},{"title":"Rosseland_reff – Rosseland Clouds","text":"subroutine Rosseland_reff(sp, sigma) Uses lxmie_mod Rosseland_data_mod allocate end Rosseland mean arrays\nAllocate reff array\nNow calculate ssa and g Arguments Type Intent Optional Attributes Name character(len=100), intent(in) :: sp real(kind=dp), intent(in) :: sigma","tags":"","loc":"proc/rosseland_reff.html"},{"title":"Planck_reff – Rosseland Clouds","text":"subroutine Planck_reff(sp, sigma) Uses lxmie_mod Rosseland_data_mod allocate end Rosseland mean arrays\nAllocate reff array\nNow calculate ssa and g Arguments Type Intent Optional Attributes Name character(len=100), intent(in) :: sp real(kind=dp), intent(in) :: sigma","tags":"","loc":"proc/planck_reff.html"},{"title":"Rosseland_lognorm – Rosseland Clouds","text":"subroutine Rosseland_lognorm(sp, N0, sigma, rmin, rmax, iint) Uses lxmie_mod Rosseland_data_mod allocate work arrays for each wavelength\nallocate end Rosseland mean arrays\nCalculate sizes to integrate lognormal function from\nNumber density assuming size r_r(i) at median size a(aa)\nIntegrated normalised log-normal properties at wavelength l\nNow calculate ssa and g Arguments Type Intent Optional Attributes Name character(len=100), intent(in) :: sp real(kind=dp), intent(in) :: N0 real(kind=dp), intent(in) :: sigma real(kind=dp), intent(in) :: rmin real(kind=dp), intent(in) :: rmax integer, intent(in) :: iint","tags":"","loc":"proc/rosseland_lognorm.html"},{"title":"Spectral_reff – Rosseland Clouds","text":"subroutine Spectral_reff(sp, r_med, sigma) Uses lxmie_mod Rosseland_data_mod Arguments Type Intent Optional Attributes Name character(len=100), intent(in) :: sp real(kind=dp), intent(in) :: r_med real(kind=dp), intent(in) :: sigma","tags":"","loc":"proc/spectral_reff.html"},{"title":"Spectral_lognorm – Rosseland Clouds","text":"subroutine Spectral_lognorm(sp, N0, r_med, sigma, rmin, rmax, iint) Uses lxmie_mod Rosseland_data_mod allocate work arrays for each log-normal size\nCalculate sizes to integrate lognormal function from\nNumber density assuming size r_r(i) at median size r_med\nIntegrated normalised log-normal properties at wavelength l\nNow calculate ssa and g Arguments Type Intent Optional Attributes Name character(len=100), intent(in) :: sp real(kind=dp), intent(in) :: N0 real(kind=dp), intent(in) :: r_med real(kind=dp), intent(in) :: sigma real(kind=dp), intent(in) :: rmin real(kind=dp), intent(in) :: rmax integer, intent(in) :: iint","tags":"","loc":"proc/spectral_lognorm.html"},{"title":"Planck_lognorm – Rosseland Clouds","text":"subroutine Planck_lognorm(sp, N0, sigma, rmin, rmax, iint) Uses lxmie_mod Rosseland_data_mod allocate work arrays for each wavelength\nallocate end Planck mean arrays\nCalculate sizes to integrate lognormal function from\nNumber density assuming size r_r(i) at median size a(aa)\nIntegrated normalised log-normal properties at wavelength l\nNow calculate ssa and g Arguments Type Intent Optional Attributes Name character(len=100), intent(in) :: sp real(kind=dp), intent(in) :: N0 real(kind=dp), intent(in) :: sigma real(kind=dp), intent(in) :: rmin real(kind=dp), intent(in) :: rmax integer, intent(in) :: iint","tags":"","loc":"proc/planck_lognorm.html"},{"title":"lxmie – Rosseland Clouds","text":"public  subroutine lxmie(ri, x, q_ext, q_sca, q_abs, g) Allocate the mie coffiecent arrays Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: ri real(kind=dp), intent(in) :: x real(kind=dp), intent(out) :: q_ext real(kind=dp), intent(out) :: q_sca real(kind=dp), intent(out) :: q_abs real(kind=dp), intent(out) :: g","tags":"","loc":"proc/lxmie.html"},{"title":"trapz – Rosseland Clouds","text":"public  function trapz(xx, yy) result(rr) Calculates the integral of an array y with respect to x using the trapezoid\napproximation. Note that the mesh spacing of x does not have to be uniform. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: xx (:) Variable x real(kind=dp), intent(in) :: yy (size(xx)) Function y(x) Return Value real(kind=dp) Integral ∫y(x)·dx","tags":"","loc":"proc/trapz.html"},{"title":"Planck_mean – Rosseland Clouds","text":"public  subroutine Planck_mean(nwl, wl, temp, Vl, Vr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nwl real(kind=dp), intent(in), dimension(nwl) :: wl real(kind=dp), intent(in) :: temp real(kind=dp), intent(in), dimension(nwl) :: Vl real(kind=dp), intent(out) :: Vr","tags":"","loc":"proc/planck_mean.html"},{"title":"Ross_mean – Rosseland Clouds","text":"public  subroutine Ross_mean(nwl, wl, temp, Vl, Vr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nwl real(kind=dp), intent(in), dimension(nwl) :: wl real(kind=dp), intent(in) :: temp real(kind=dp), intent(in), dimension(nwl) :: Vl real(kind=dp), intent(out) :: Vr","tags":"","loc":"proc/ross_mean.html"},{"title":"read_RT_table – Rosseland Clouds","text":"public  subroutine read_RT_table(RT_path) Arguments Type Intent Optional Attributes Name character(len=100), intent(in) :: RT_path","tags":"","loc":"proc/read_rt_table.html"},{"title":"read_nk_data – Rosseland Clouds","text":"public  subroutine read_nk_data(nk_path) Arguments Type Intent Optional Attributes Name character(len=100), intent(in) :: nk_path","tags":"","loc":"proc/read_nk_data.html"},{"title":"read_wavelength_table – Rosseland Clouds","text":"public  subroutine read_wavelength_table(wl_path) Arguments Type Intent Optional Attributes Name character(len=100), intent(in) :: wl_path","tags":"","loc":"proc/read_wavelength_table.html"},{"title":"interp_nk – Rosseland Clouds","text":"public  subroutine interp_nk() Arguments None","tags":"","loc":"proc/interp_nk.html"},{"title":"lxmie_mod – Rosseland Clouds","text":"Calculates the Mie coefficients a and b that are used for the construction of the Mie series, see Eq. 17\nThe required coefficients A_n are calculated via downward recursion, B_n and C_n by upward recursion\na and b are evaluated up to a number of \"nb_mie_terms\"\nCalculates the Mie efficiencies, see Eq. 1\nThe absorption efficiency is calculated as the difference of the extinction and scattering efficiencies\nCalculate and return the asymmetry parameter\nSee Bohren&Huffman, page 120, for details on the equation\nCalculate the starting value of A_N via the method of continued fractions by Lentz (1976)\nConvergence is reached if two consecutive terms differ by less than \"continued_fraction_epsilon\"\nReturns A_N\nThis is the version for a complex A_N \nCalculate the starting value of A_N via the method of continued fractions by Lentz (1976)\nConvergence is reached if two consecutive terms differ by less than \"continued_fraction_epsilon\"\nReturns A_N\nThis is the version for a real A_N\nCalculates single terms a_n used in the evaluation of the continued fractions by Lentz (1976)\nSee Eq. 9 in Lentz (1976)\nThis is the version for a complex a_n \nCalculates single terms a_n used in the evaluation of the continued fractions by Lentz (1976)\nSee Eq. 9 in Lentz (1976)\nThis is the version for a real-numbered a_n Uses iso_fortran_env Variables Type Visibility Attributes Name Initial integer, public, parameter :: dp = REAL64 integer, public, parameter :: cf_max_terms = 10000001 real(kind=dp), public, parameter :: cf_epsilon = 1.0e-10_dp Subroutines public  subroutine lxmie (ri, x, q_ext, q_sca, q_abs, g) Allocate the mie coffiecent arrays Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: ri real(kind=dp), intent(in) :: x real(kind=dp), intent(out) :: q_ext real(kind=dp), intent(out) :: q_sca real(kind=dp), intent(out) :: q_abs real(kind=dp), intent(out) :: g","tags":"","loc":"module/lxmie_mod.html"},{"title":"Rosseland_data_mod – Rosseland Clouds","text":"Uses iso_fortran_env Variables Type Visibility Attributes Name Initial integer, public, parameter :: dp = REAL64 real(kind=dp), public, parameter :: pi = 4.0_dp*atan(1.0_dp) real(kind=dp), public, parameter :: twopi = 2.0_dp*pi real(kind=dp), public, parameter :: hp = 6.62607015e-27_dp real(kind=dp), public, parameter :: c_s = 2.99792458e10_dp real(kind=dp), public, parameter :: kb = 1.380649e-16_dp integer, public :: nwl integer, public :: na integer, public :: nT real(kind=dp), public, allocatable, dimension(:) :: a real(kind=dp), public, allocatable, dimension(:) :: T real(kind=dp), public, allocatable, dimension(:) :: wl logical, public :: c_flag integer, public :: nlines real(kind=dp), public, allocatable, dimension(:) :: wl_ori real(kind=dp), public, allocatable, dimension(:) :: n_ori real(kind=dp), public, allocatable, dimension(:) :: k_ori real(kind=dp), public, allocatable, dimension(:) :: n_int real(kind=dp), public, allocatable, dimension(:) :: k_int Functions public  function trapz (xx, yy) result(rr) Calculates the integral of an array y with respect to x using the trapezoid\napproximation. Note that the mesh spacing of x does not have to be uniform. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: xx (:) Variable x real(kind=dp), intent(in) :: yy (size(xx)) Function y(x) Return Value real(kind=dp) Integral ∫y(x)·dx Subroutines public  subroutine Planck_mean (nwl, wl, temp, Vl, Vr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nwl real(kind=dp), intent(in), dimension(nwl) :: wl real(kind=dp), intent(in) :: temp real(kind=dp), intent(in), dimension(nwl) :: Vl real(kind=dp), intent(out) :: Vr public  subroutine Ross_mean (nwl, wl, temp, Vl, Vr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nwl real(kind=dp), intent(in), dimension(nwl) :: wl real(kind=dp), intent(in) :: temp real(kind=dp), intent(in), dimension(nwl) :: Vl real(kind=dp), intent(out) :: Vr public  subroutine read_RT_table (RT_path) Arguments Type Intent Optional Attributes Name character(len=100), intent(in) :: RT_path public  subroutine read_nk_data (nk_path) Arguments Type Intent Optional Attributes Name character(len=100), intent(in) :: nk_path public  subroutine read_wavelength_table (wl_path) Arguments Type Intent Optional Attributes Name character(len=100), intent(in) :: wl_path public  subroutine interp_nk () Arguments None","tags":"","loc":"module/rosseland_data_mod.html"},{"title":"Rosseland_main – Rosseland Clouds","text":"Uses Rosseland_data_mod Variables Type Attributes Name Initial integer :: meth character(len=100) :: wl_path character(len=100) :: sp character(len=100) :: nk_path character(len=100) :: RT_path integer :: iint real(kind=dp) :: N0 real(kind=dp) :: r_med real(kind=dp) :: sigma real(kind=dp) :: rmin real(kind=dp) :: rmax integer :: u_nml Namelists Namelist Rosseland_clouds_nml Read input variables from main namelist Variables Name Type Default Description meth integer None wl_path character(len=100) None sp character(len=100) None nk_path character(len=100) None RT_path character(len=100) None N0 real(kind=dp) None r_med real(kind=dp) None sigma real(kind=dp) None rmin real(kind=dp) None rmax real(kind=dp) None iint integer None","tags":"","loc":"program/rosseland_main.html"},{"title":"  Rosseland_clouds_nml %ndash; Rosseland Clouds\n","text":"Read input variables from main namelist Variables Name Type Default Description meth integer None wl_path character(len=100) None sp character(len=100) None nk_path character(len=100) None RT_path character(len=100) None N0 real(kind=dp) None r_med real(kind=dp) None sigma real(kind=dp) None rmin real(kind=dp) None rmax real(kind=dp) None iint integer None","tags":"","loc":"namelist/rosseland_clouds_nml.html"},{"title":"Spectral_single.f90 – Rosseland Clouds","text":"Source Code subroutine Spectral_single ( sp , r_med ) use Rosseland_data_mod use lxmie_mod , only : lxmie implicit none real ( dp ), intent ( in ) :: r_med character ( len = 100 ), intent ( in ) :: sp integer :: l , u_rmed complex ( dp ) :: ri real ( dp ) :: x , xsec , q_ext , q_sca , q_abs , g real ( dp ), allocatable , dimension (:) :: kext_l , a_l , g_l ! Perform Mie calculations allocate ( kext_l ( nwl ), a_l ( nwl ), g_l ( nwl )) do l = 1 , nwl print * , l , nwl , real ( wl ( l )) ! Complex refractive index ri = cmplx ( n_int ( l ), - k_int ( l ), dp ) ! Size parameter x = ( twopi * r_med ) / wl ( l ) ! cross section xsec = pi * ( r_med * 1e-4_dp ) ** 2 ! Call Mie routine for this size and wavelength call lxmie ( ri , x , q_ext , q_sca , q_abs , g ) kext_l ( l ) = xsec * q_ext ! Units of kext_l [cm2] a_l ( l ) = q_sca / q_ext g_l ( l ) = g end do ! Output table for each wavelanth open ( newunit = u_rmed , file = 'results_Spectral_single/' // trim ( sp ) // '_single.txt' , action = 'readwrite' ) write ( u_rmed , * ) r_med , nwl do l = 1 , nwl write ( u_rmed , * ) wl ( l ), kext_l ( l ), a_l ( l ), g_l ( l ) call flush ( u_rmed ) end do close ( u_rmed ) end subroutine Spectral_single","tags":"","loc":"sourcefile/spectral_single.f90.html"},{"title":"Rosseland_main.f90 – Rosseland Clouds","text":"Source Code program Rosseland_main use Rosseland_data_mod implicit none integer :: meth character ( len = 100 ) :: wl_path , sp , nk_path , RT_path integer :: iint real ( dp ) :: N0 , r_med , sigma , rmin , rmax integer :: u_nml namelist / Rosseland_clouds_nml / & & meth , wl_path , sp , nk_path , RT_path , & & N0 , r_med , sigma , rmin , rmax , iint !! Read input variables from main namelist open ( newunit = u_nml , file = 'Rosseland_clouds.nml' , status = 'old' , action = 'read' ) read ( u_nml , nml = Rosseland_clouds_nml ) close ( u_nml ) !print*, meth, wl_path, sp, nk_path, RT_path !print*, r_med, sigma, rmin, rmax, iint call read_wavelength_table ( wl_path ) call read_RT_table ( RT_path ) call read_nk_data ( nk_path ) call interp_nk () select case ( meth ) case ( 1 ) call Rosseland_single ( sp ) case ( 2 ) call Rosseland_lognorm ( sp , N0 , sigma , rmin , rmax , iint ) case ( 3 ) call Rosseland_reff ( sp , sigma ) case ( 4 ) call Spectral_single ( sp , r_med ) case ( 5 ) call Spectral_lognorm ( sp , N0 , r_med , sigma , rmin , rmax , iint ) case ( 6 ) call Spectral_reff ( sp , r_med , sigma ) case ( 7 ) call Planck_single ( sp ) case ( 8 ) call Planck_lognorm ( sp , N0 , sigma , rmin , rmax , iint ) case ( 9 ) call Planck_reff ( sp , sigma ) case default print * , 'Invalid method integer selected' , meth end select end program Rosseland_main","tags":"","loc":"sourcefile/rosseland_main.f90.html"},{"title":"Rosseland_single.f90 – Rosseland Clouds","text":"Source Code subroutine Rosseland_single ( sp ) use Rosseland_data_mod use lxmie_mod , only : lxmie implicit none character ( len = 100 ), intent ( in ) :: sp integer :: aa , tt , l , u_k , u_a , u_g real ( dp ), dimension (:), allocatable :: kext_l , a_l , g_l real ( dp ), dimension (:, :), allocatable :: Ross_kext , Ross_a , Ross_g complex ( dp ) :: ri real ( dp ) :: x , xsec , q_ext , q_sca , q_abs , g !! Perform Mie calculations !! allocate work arrays for each wavelength allocate ( kext_l ( nwl ), a_l ( nwl ), g_l ( nwl )) !! allocate end Rosseland mean arrays allocate ( Ross_kext ( na , nT ), Ross_a ( na , nT ), Ross_g ( na , nT )) do aa = 1 , na print * , a ( aa ), aa , na ! Cross section xsec = pi * ( a ( aa ) * 1e-4_dp ) ** 2 do tt = 1 , nt do l = 1 , nwl ! Optical constant ri = cmplx ( n_int ( l ), - k_int ( l ), dp ) ! Size parameter x = ( twopi * a ( aa )) / wl ( l ) call lxmie ( ri , x , q_ext , q_sca , q_abs , g ) kext_l ( l ) = xsec * q_ext a_l ( l ) = xsec * q_sca g_l ( l ) = max ( g , 1.0e-12_dp ) * xsec * q_sca !print*, a(aa), wl(l), x, q_ext, q_sca, g end do call Ross_mean ( nwl , wl (:), T ( tt ), kext_l (:), Ross_kext ( aa , tt )) call Ross_mean ( nwl , wl (:), T ( tt ), a_l (:), Ross_a ( aa , tt )) call Ross_mean ( nwl , wl (:), T ( tt ), g_l (:), Ross_g ( aa , tt )) !! Now calculate ssa and g ! g is scattering opacity weighted by g divided by scattering opacity Ross_g ( aa , tt ) = Ross_g ( aa , tt ) / Ross_a ( aa , tt ) ! ssa is scattering opacity divided by extinction opacity Ross_a ( aa , tt ) = Ross_a ( aa , tt ) / Ross_kext ( aa , tt ) end do end do ! Output table - go radius outer loop, temperature inner loop ! Output cross section, ssa and g open ( newunit = u_k , file = 'results_Rosseland_single/' // trim ( sp ) // '_kext.txt' , action = 'readwrite' ) write ( u_k , * ) na , nT write ( u_k , * ) a (:) write ( u_k , * ) T (:) do aa = 1 , na write ( u_k , * ) ( real ( Ross_kext ( aa , tt )), tt = 1 , nT ) call flush ( u_k ) end do close ( u_k ) open ( newunit = u_a , file = 'results_Rosseland_single/' // trim ( sp ) // '_a.txt' , action = 'readwrite' ) write ( u_a , * ) na , nT write ( u_a , * ) a (:) write ( u_a , * ) T (:) do aa = 1 , na write ( u_a , * ) ( real ( Ross_a ( aa , tt )), tt = 1 , nT ) call flush ( u_a ) end do close ( u_a ) open ( newunit = u_g , file = 'results_Rosseland_single/' // trim ( sp ) // '_g.txt' , action = 'readwrite' ) write ( u_g , * ) na , nT write ( u_g , * ) a (:) write ( u_g , * ) T (:) do aa = 1 , na write ( u_g , * ) ( real ( Ross_g ( aa , tt )), tt = 1 , nT ) call flush ( u_g ) end do close ( u_g ) end subroutine Rosseland_single","tags":"","loc":"sourcefile/rosseland_single.f90.html"},{"title":"Planck_single.f90 – Rosseland Clouds","text":"Source Code subroutine Planck_single ( sp ) use Rosseland_data_mod use lxmie_mod , only : lxmie implicit none character ( len = 100 ), intent ( in ) :: sp integer :: aa , tt , l , u_k , u_a , u_g real ( dp ), dimension (:), allocatable :: kext_l , a_l , g_l real ( dp ), dimension (:, :), allocatable :: Pl_kext , Pl_a , Pl_g complex ( dp ) :: ri real ( dp ) :: x , xsec , q_ext , q_sca , q_abs , g !! Perform Mie calculations !! allocate work arrays for each wavelength allocate ( kext_l ( nwl ), a_l ( nwl ), g_l ( nwl )) !! allocate end Planck mean arrays allocate ( Pl_kext ( na , nT ), Pl_a ( na , nT ), Pl_g ( na , nT )) do aa = 1 , na print * , a ( aa ), aa , na ! Cross section xsec = pi * ( a ( aa ) * 1e-4_dp ) ** 2 do tt = 1 , nt do l = 1 , nwl ! Optical constant ri = cmplx ( n_int ( l ), - k_int ( l ), dp ) ! Size parameter x = ( twopi * a ( aa )) / wl ( l ) call lxmie ( ri , x , q_ext , q_sca , q_abs , g ) kext_l ( l ) = xsec * q_ext a_l ( l ) = xsec * q_sca g_l ( l ) = max ( g , 1.0e-12_dp ) * xsec * q_sca !print*, a(aa), wl(l), x, q_ext, q_sca, g end do call Planck_mean ( nwl , wl (:), T ( tt ), kext_l (:), Pl_kext ( aa , tt )) call Planck_mean ( nwl , wl (:), T ( tt ), a_l (:), Pl_a ( aa , tt )) call Planck_mean ( nwl , wl (:), T ( tt ), g_l (:), Pl_g ( aa , tt )) !! Now calculate ssa and g ! g is scattering opacity weighted by g divided by scattering opacity Pl_g ( aa , tt ) = Pl_g ( aa , tt ) / Pl_a ( aa , tt ) ! ssa is scattering opacity divided by extinction opacity Pl_a ( aa , tt ) = Pl_a ( aa , tt ) / Pl_kext ( aa , tt ) end do end do ! Output table - go radius outer loop, temperature inner loop ! Output cross section, ssa and g open ( newunit = u_k , file = 'results_Planck_single/' // trim ( sp ) // '_kext.txt' , action = 'readwrite' ) write ( u_k , * ) na , nT write ( u_k , * ) a (:) write ( u_k , * ) T (:) do aa = 1 , na write ( u_k , * ) ( real ( Pl_kext ( aa , tt )), tt = 1 , nT ) call flush ( u_k ) end do close ( u_k ) open ( newunit = u_a , file = 'results_Planck_single/' // trim ( sp ) // '_a.txt' , action = 'readwrite' ) write ( u_a , * ) na , nT write ( u_a , * ) a (:) write ( u_a , * ) T (:) do aa = 1 , na write ( u_a , * ) ( real ( Pl_a ( aa , tt )), tt = 1 , nT ) call flush ( u_a ) end do close ( u_a ) open ( newunit = u_g , file = 'results_Planck_single/' // trim ( sp ) // '_g.txt' , action = 'readwrite' ) write ( u_g , * ) na , nT write ( u_g , * ) a (:) write ( u_g , * ) T (:) do aa = 1 , na write ( u_g , * ) ( real ( Pl_g ( aa , tt )), tt = 1 , nT ) call flush ( u_g ) end do close ( u_g ) end subroutine Planck_single","tags":"","loc":"sourcefile/planck_single.f90.html"},{"title":"Rosseland_reff.f90 – Rosseland Clouds","text":"Source Code subroutine Rosseland_reff ( sp , sigma ) use Rosseland_data_mod use lxmie_mod , only : lxmie implicit none real ( dp ), intent ( in ) :: sigma character ( len = 100 ), intent ( in ) :: sp integer :: aa , tt , l , u_k , u_a , u_g real ( dp ), dimension (:), allocatable :: kext_l , a_l , g_l real ( dp ), dimension (:,:), allocatable :: Ross_kext , Ross_a , Ross_g complex ( dp ) :: ri real ( dp ) :: x , xsec , q_ext , q_sca , q_abs , g real ( dp ), allocatable , dimension (:) :: reff !! Perform Mie calculations !! allocate work arrays for each wavelength allocate ( kext_l ( nwl ), a_l ( nwl ), g_l ( nwl )) !! allocate end Rosseland mean arrays allocate ( Ross_kext ( na , nT ), Ross_a ( na , nT ), Ross_g ( na , nT )) !! Allocate reff array allocate ( reff ( na )) do aa = 1 , na ! Effective radius for log-normal reff ( aa ) = a ( aa ) * exp ( 5.0_dp / 2.0_dp * log ( sigma ) ** 2 ) print * , a ( aa ), reff ( aa ), aa , na ! Cross section xsec = pi * ( reff ( aa ) * 1e-4_dp ) ** 2 do tt = 1 , nt do l = 1 , nwl ! Optical constant ri = cmplx ( n_int ( l ), - k_int ( l ), dp ) ! Size parameter x = ( twopi * reff ( aa )) / wl ( l ) call lxmie ( ri , x , q_ext , q_sca , q_abs , g ) kext_l ( l ) = xsec * q_ext a_l ( l ) = xsec * q_sca g_l ( l ) = max ( g , 1.0e-12_dp ) * xsec * q_sca !print*, a(aa), wl(l), x, q_ext, q_sca, g end do call Ross_mean ( nwl , wl (:), T ( tt ), kext_l (:), Ross_kext ( aa , tt )) call Ross_mean ( nwl , wl (:), T ( tt ), a_l (:), Ross_a ( aa , tt )) call Ross_mean ( nwl , wl (:), T ( tt ), g_l (:), Ross_g ( aa , tt )) !! Now calculate ssa and g ! g is scattering opacity weighted by g divided by scattering opacity Ross_g ( aa , tt ) = Ross_g ( aa , tt ) / Ross_a ( aa , tt ) ! ssa is scattering opacity divided by extinction opacity Ross_a ( aa , tt ) = Ross_a ( aa , tt ) / Ross_kext ( aa , tt ) end do end do ! Output table - go radius outer loop, temperature inner loop ! Output cross section, ssa and g open ( newunit = u_k , file = 'results_Rosseland_reff/' // trim ( sp ) // '_kext.txt' , action = 'readwrite' ) write ( u_k , * ) na , nT , sigma write ( u_k , * ) a (:) write ( u_k , * ) reff (:) write ( u_k , * ) T (:) do aa = 1 , na write ( u_k , * ) ( real ( Ross_kext ( aa , tt )), tt = 1 , nT ) call flush ( u_k ) end do close ( u_k ) open ( newunit = u_a , file = 'results_Rosseland_reff/' // trim ( sp ) // '_a.txt' , action = 'readwrite' ) write ( u_a , * ) na , nT , sigma write ( u_a , * ) a (:) write ( u_a , * ) reff (:) write ( u_a , * ) T (:) do aa = 1 , na write ( u_a , * ) ( real ( Ross_a ( aa , tt )), tt = 1 , nT ) call flush ( u_a ) end do close ( u_a ) open ( newunit = u_g , file = 'results_Rosseland_reff/' // trim ( sp ) // '_g.txt' , action = 'readwrite' ) write ( u_g , * ) na , nT , sigma write ( u_g , * ) a (:) write ( u_g , * ) reff (:) write ( u_g , * ) T (:) do aa = 1 , na write ( u_g , * ) ( real ( Ross_g ( aa , tt )), tt = 1 , nT ) call flush ( u_g ) end do close ( u_g ) end subroutine Rosseland_reff","tags":"","loc":"sourcefile/rosseland_reff.f90.html"},{"title":"Planck_reff.f90 – Rosseland Clouds","text":"Source Code subroutine Planck_reff ( sp , sigma ) use Rosseland_data_mod use lxmie_mod , only : lxmie implicit none real ( dp ), intent ( in ) :: sigma character ( len = 100 ), intent ( in ) :: sp integer :: aa , tt , l , u_k , u_a , u_g real ( dp ), dimension (:), allocatable :: kext_l , a_l , g_l real ( dp ), dimension (:,:), allocatable :: Pl_kext , Pl_a , Pl_g complex ( dp ) :: ri real ( dp ) :: x , xsec , q_ext , q_sca , q_abs , g real ( dp ), allocatable , dimension (:) :: reff !! Perform Mie calculations !! allocate work arrays for each wavelength allocate ( kext_l ( nwl ), a_l ( nwl ), g_l ( nwl )) !! allocate end Rosseland mean arrays allocate ( Pl_kext ( na , nT ), Pl_a ( na , nT ), Pl_g ( na , nT )) !! Allocate reff array allocate ( reff ( na )) do aa = 1 , na ! Effective radius for log-normal reff ( aa ) = a ( aa ) * exp ( 5.0_dp / 2.0_dp * log ( sigma ) ** 2 ) print * , a ( aa ), reff ( aa ), aa , na ! Cross section xsec = pi * ( reff ( aa ) * 1e-4_dp ) ** 2 do tt = 1 , nt do l = 1 , nwl ! Optical constant ri = cmplx ( n_int ( l ), - k_int ( l ), dp ) ! Size parameter x = ( twopi * reff ( aa )) / wl ( l ) call lxmie ( ri , x , q_ext , q_sca , q_abs , g ) kext_l ( l ) = xsec * q_ext a_l ( l ) = xsec * q_sca g_l ( l ) = max ( g , 1.0e-12_dp ) * xsec * q_sca !print*, a(aa), wl(l), x, q_ext, q_sca, g end do call Planck_mean ( nwl , wl (:), T ( tt ), kext_l (:), Pl_kext ( aa , tt )) call Planck_mean ( nwl , wl (:), T ( tt ), a_l (:), Pl_a ( aa , tt )) call Planck_mean ( nwl , wl (:), T ( tt ), g_l (:), Pl_g ( aa , tt )) !! Now calculate ssa and g ! g is scattering opacity weighted by g divided by scattering opacity Pl_g ( aa , tt ) = Pl_g ( aa , tt ) / Pl_a ( aa , tt ) ! ssa is scattering opacity divided by extinction opacity Pl_a ( aa , tt ) = Pl_a ( aa , tt ) / Pl_kext ( aa , tt ) end do end do ! Output table - go radius outer loop, temperature inner loop ! Output cross section, ssa and g open ( newunit = u_k , file = 'results_Planck_reff/' // trim ( sp ) // '_kext.txt' , action = 'readwrite' ) write ( u_k , * ) na , nT , sigma write ( u_k , * ) a (:) write ( u_k , * ) reff (:) write ( u_k , * ) T (:) do aa = 1 , na write ( u_k , * ) ( real ( Pl_kext ( aa , tt )), tt = 1 , nT ) call flush ( u_k ) end do close ( u_k ) open ( newunit = u_a , file = 'results_Planck_reff/' // trim ( sp ) // '_a.txt' , action = 'readwrite' ) write ( u_a , * ) na , nT , sigma write ( u_a , * ) a (:) write ( u_a , * ) reff (:) write ( u_a , * ) T (:) do aa = 1 , na write ( u_a , * ) ( real ( Pl_a ( aa , tt )), tt = 1 , nT ) call flush ( u_a ) end do close ( u_a ) open ( newunit = u_g , file = 'results_Planck_reff/' // trim ( sp ) // '_g.txt' , action = 'readwrite' ) write ( u_g , * ) na , nT , sigma write ( u_g , * ) a (:) write ( u_g , * ) reff (:) write ( u_g , * ) T (:) do aa = 1 , na write ( u_g , * ) ( real ( Pl_g ( aa , tt )), tt = 1 , nT ) call flush ( u_g ) end do close ( u_g ) end subroutine Planck_reff","tags":"","loc":"sourcefile/planck_reff.f90.html"},{"title":"Rosseland_lognorm.f90 – Rosseland Clouds","text":"Source Code subroutine Rosseland_lognorm ( sp , N0 , sigma , rmin , rmax , iint ) use Rosseland_data_mod use lxmie_mod , only : lxmie implicit none character ( len = 100 ), intent ( in ) :: sp integer , intent ( in ) :: iint real ( dp ), intent ( in ) :: N0 , sigma , rmin , rmax integer :: i , aa , tt , l , u_k , u_a , u_g real ( dp ), dimension (:), allocatable :: kext_r , a_r , g_r , nd_r , r_r real ( dp ), dimension (:), allocatable :: kext_l , a_l , g_l real ( dp ), dimension (:, :), allocatable :: Ross_kext , Ross_a , Ross_g complex ( dp ) :: ri real ( dp ) :: x , xsec , q_ext , q_sca , q_abs , g real ( dp ) :: lamin , lamax !! Perform Mie calculations !! allocate work arrays for each log-normal size allocate ( kext_r ( iint ), a_r ( iint ), g_r ( iint ), r_r ( iint ), nd_r ( iint )) !! allocate work arrays for each wavelength allocate ( kext_l ( nwl ), a_l ( nwl ), g_l ( nwl )) !! allocate end Rosseland mean arrays allocate ( Ross_kext ( na , nT ), Ross_a ( na , nT ), Ross_g ( na , nT )) !! Calculate sizes to integrate lognormal function from lamin = log10 ( rmin ) lamax = log10 ( rmax ) do i = 1 , iint r_r ( i ) = 1 0.0_dp ** (( lamax - lamin ) * real ( i - 1 , kind = dp ) / real ( iint - 1 , kind = dp ) + lamin ) !print*, i, r_r(i) end do do aa = 1 , na print * , a ( aa ), aa , na do tt = 1 , nt do l = 1 , nwl ! Optical constant ri = cmplx ( n_int ( l ), - k_int ( l ), dp ) do i = 1 , iint !! Number density assuming size r_r(i) at median size a(aa) nd_r ( i ) = N0 / ( r_r ( i ) * 1e-4_dp * sqrt ( 2.0_dp * pi ) * log ( sigma )) * & & exp ( - ( log ( r_r ( i ) / ( a ( aa ))) ** 2 ) / ( 2.0_dp * log ( sigma ) ** 2 )) ! Limiter for underflow nd_r ( i ) = max ( nd_r ( i ), 1e-30_dp ) ! Cross section xsec = pi * ( r_r ( i ) * 1e-4_dp ) ** 2 ! Size parameter x = ( twopi * r_r ( i )) / wl ( l ) call lxmie ( ri , x , q_ext , q_sca , q_abs , g ) kext_r ( i ) = xsec * q_ext * nd_r ( i ) a_r ( i ) = xsec * q_sca * nd_r ( i ) g_r ( i ) = max ( g , 1.0e-12_dp ) * xsec * q_sca * nd_r ( i ) end do !! Integrated normalised log-normal properties at wavelength l kext_l ( l ) = trapz ( r_r (:) * 1e-4_dp , kext_r (:)) a_l ( l ) = trapz ( r_r (:) * 1e-4_dp , a_r (:)) g_l ( l ) = trapz ( r_r (:) * 1e-4_dp , g_r (:)) !print*, a(aa), wl(l), x, q_ext, q_sca, g end do call Ross_mean ( nwl , wl (:), T ( tt ), kext_l (:), Ross_kext ( aa , tt )) call Ross_mean ( nwl , wl (:), T ( tt ), a_l (:), Ross_a ( aa , tt )) call Ross_mean ( nwl , wl (:), T ( tt ), g_l (:), Ross_g ( aa , tt )) !! Now calculate ssa and g ! g is scattering opacity weighted by g divided by scattering opacity Ross_g ( aa , tt ) = Ross_g ( aa , tt ) / Ross_a ( aa , tt ) ! ssa is scattering opacity divided by extinction opacity Ross_a ( aa , tt ) = Ross_a ( aa , tt ) / Ross_kext ( aa , tt ) end do end do ! Output table - go radius outer loop, temperature inner loop ! Output cross section, ssa and g open ( newunit = u_k , file = 'results_Rosseland_lognorm/' // trim ( sp ) // '_kext.txt' , action = 'readwrite' ) write ( u_k , * ) na , nT , sigma write ( u_k , * ) a (:) write ( u_k , * ) T (:) do aa = 1 , na write ( u_k , * ) ( real ( Ross_kext ( aa , tt )), tt = 1 , nT ) call flush ( u_k ) end do close ( u_k ) open ( newunit = u_a , file = 'results_Rosseland_lognorm/' // trim ( sp ) // '_a.txt' , action = 'readwrite' ) write ( u_a , * ) na , nT , sigma write ( u_a , * ) a (:) write ( u_a , * ) T (:) do aa = 1 , na write ( u_a , * ) ( real ( Ross_a ( aa , tt )), tt = 1 , nT ) call flush ( u_a ) end do close ( u_a ) open ( newunit = u_g , file = 'results_Rosseland_lognorm/' // trim ( sp ) // '_g.txt' , action = 'readwrite' ) write ( u_g , * ) na , nT , sigma write ( u_g , * ) a (:) write ( u_g , * ) T (:) do aa = 1 , na write ( u_g , * ) ( real ( Ross_g ( aa , tt )), tt = 1 , nT ) call flush ( u_g ) end do close ( u_g ) end subroutine Rosseland_lognorm","tags":"","loc":"sourcefile/rosseland_lognorm.f90.html"},{"title":"Spectral_reff.f90 – Rosseland Clouds","text":"Source Code subroutine Spectral_reff ( sp , r_med , sigma ) use Rosseland_data_mod use lxmie_mod , only : lxmie implicit none real ( dp ), intent ( in ) :: r_med , sigma character ( len = 100 ), intent ( in ) :: sp integer :: l , u_reff complex ( dp ) :: ri real ( dp ) :: x , xsec , q_ext , q_sca , q_abs , g , r_eff real ( dp ), allocatable , dimension (:) :: kext_l , a_l , g_l ! Perform Mie calculations allocate ( kext_l ( nwl ), a_l ( nwl ), g_l ( nwl )) ! Find effective radius from lognormal parameters r_eff = r_med * exp ( 5.0_dp / 2.0_dp * log ( sigma ) ** 2 ) do l = 1 , nwl print * , l , nwl , real ( wl ( l )) ! Complex refractive index ri = cmplx ( n_int ( l ), - k_int ( l ), dp ) ! Size parameter x = ( twopi * r_eff ) / wl ( l ) ! cross section xsec = pi * ( r_eff * 1e-4_dp ) ** 2 ! Call Mie routine for this size and wavelength call lxmie ( ri , x , q_ext , q_sca , q_abs , g ) kext_l ( l ) = xsec * q_ext ! Units of kext_l [cm2] a_l ( l ) = q_sca / q_ext g_l ( l ) = g end do ! Output table for each wavelanth open ( newunit = u_reff , file = 'results_Spectral_reff/' // trim ( sp ) // '_reff.txt' , action = 'readwrite' ) write ( u_reff , * ) r_med , r_eff , sigma , nwl do l = 1 , nwl write ( u_reff , * ) wl ( l ), kext_l ( l ), a_l ( l ), g_l ( l ) call flush ( u_reff ) end do close ( u_reff ) end subroutine Spectral_reff","tags":"","loc":"sourcefile/spectral_reff.f90.html"},{"title":"lxmie_mod.f90 – Rosseland Clouds","text":"! E.K.H. Lee -  Translation into fortran 90 of the c++ code LX-MIE from Kitzmann & Heng (2018)\n! original comments have been retained\n! - input : ri - refractive index (with negative k, m = n - k), x size parameter\n! - output : q_ext, qsca, q_abs efficencies and asymmetry parameter (g)\n! - Source Code !!! E.K.H. Lee -  Translation into fortran 90 of the c++ code LX-MIE from Kitzmann & Heng (2018) !!! original comments have been retained !!! - input : ri - refractive index (with negative k, m = n - k), x size parameter !!! - output : q_ext, qsca, q_abs efficencies and asymmetry parameter (g) !!! - module lxmie_mod use , intrinsic :: iso_fortran_env ! Requires fortran 2008 implicit none integer , parameter :: dp = REAL64 integer , parameter :: cf_max_terms = 10000001 real ( dp ), parameter :: cf_epsilon = 1.0e-10_dp public :: lxmie private :: calcMieCoefficients , calcMieEfficiencies , calcAsymmetryParameter , & & an , anReal , startingANcontinuedFractions , startingANcontinuedFractionsReal contains subroutine lxmie ( ri , x , q_ext , q_sca , q_abs , g ) implicit none complex ( dp ), intent ( in ) :: ri real ( dp ), intent ( in ) :: x real ( dp ), intent ( out ) :: q_ext , q_sca , q_abs , g integer :: nb complex ( dp ), allocatable , dimension (:) :: mie_coeff_a , mie_coeff_b !! Calculate the maximum number of terms in the Mie series !! See Eq. 22 nb = int ( x + 4.3_dp * x ** ( 1.0_dp / 3.0_dp )) + 2 !! Allocate the mie coffiecent arrays allocate ( mie_coeff_a ( nb ), mie_coeff_b ( nb )) call calcMieCoefficients ( nb , ri , x , mie_coeff_a , mie_coeff_b ) call calcMieEfficiencies ( nb , x , mie_coeff_a , mie_coeff_b , q_ext , q_sca , q_abs ) call calcAsymmetryParameter ( nb , q_sca , x , mie_coeff_a , mie_coeff_b , g ) deallocate ( mie_coeff_a , mie_coeff_b ) end subroutine lxmie !! Calculates the Mie coefficients a and b that are used for the construction of the Mie series, see Eq. 17 !! The required coefficients A_n are calculated via downward recursion, B_n and C_n by upward recursion !! a and b are evaluated up to a number of \"nb_mie_terms\" subroutine calcMieCoefficients ( nb , ri , x , mie_coeff_a , mie_coeff_b ) implicit none integer , intent ( in ) :: nb complex ( dp ), intent ( in ) :: ri real ( dp ), intent ( in ) :: x complex ( dp ), dimension ( nb ), intent ( out ) :: mie_coeff_a , mie_coeff_b integer :: n real ( dp ) :: dn complex ( dp ) :: m , mx complex ( dp ) :: C_n , D_n , A_n real ( dp ) :: A_n_r m = ri mx = m * x !! First, calculate A_n via backward recursion !! Note that we need A_N(mx), a complex number, and A_N(x), a real number (see Eq. 17) !! We use the Mie a-coefficient to store the complex values and the Mie b-coefficients for the real numbers mie_coeff_a ( nb ) = startingANcontinuedFractions ( nb , mx ) mie_coeff_b ( nb )% re = startingANcontinuedFractionsReal ( nb , x ) !! backward recursion do n = nb , 2 , - 1 dn = real ( n , dp ) mie_coeff_a ( n - 1 ) = dn / mx - 1.0_dp / ( dn / mx + mie_coeff_a ( n )) mie_coeff_b ( n - 1 )% re = dn / x - 1.0_dp / ( dn / x + real ( mie_coeff_b ( n ), dp )) end do !! Now we do a forward recursion to calculate B_n, C_n, and the Mie coefficients a_n and b_n C_n = cmplx ( 0.0_dp , 0.0_dp , dp ) D_n = cmplx ( 0.0_dp , - 1.0_dp , dp ) !! n = 1 C_n = cmplx ( 1.0_dp , ( cos ( x ) + x * sin ( x )) / ( sin ( x ) - x * cos ( x )), dp ) C_n = 1.0_dp / C_n D_n = - 1.0_dp / x + 1.0_dp / ( 1.0_dp / x - D_n ) A_n = mie_coeff_a ( 1 ) A_n_r = real ( mie_coeff_b ( 1 ), dp ) mie_coeff_a ( 1 ) = C_n * ( A_n / m - A_n_r ) / ( A_n / m - D_n ) mie_coeff_b ( 1 ) = C_n * ( A_n * m - A_n_r ) / ( A_n * m - D_n ) !! n > 1 do n = 2 , nb dn = real ( n , dp ) A_n = mie_coeff_a ( n ) A_n_r = real ( mie_coeff_b ( n ), dp ) D_n = - dn / x + 1.0_dp / ( dn / x - D_n ) C_n = C_n * ( D_n + dn / x ) / ( A_n_r + dn / x ) mie_coeff_a ( n ) = C_n * ( A_n / m - A_n_r ) / ( A_n / m - D_n ) mie_coeff_b ( n ) = C_n * ( A_n * m - A_n_r ) / ( A_n * m - D_n ) end do end subroutine calcMieCoefficients !! Calculates the Mie efficiencies, see Eq. 1 !! The absorption efficiency is calculated as the difference of the extinction and scattering efficiencies subroutine calcMieEfficiencies ( nb , x , mie_coeff_a , mie_coeff_b , q_ext , q_sca , q_abs ) implicit none integer , intent ( in ) :: nb real ( dp ), intent ( in ) :: x complex ( dp ), dimension ( nb + 1 ), intent ( in ) :: mie_coeff_a , mie_coeff_b real ( dp ), intent ( out ) :: q_ext , q_sca , q_abs integer :: n real ( dp ) :: dn q_ext = 0.0_dp q_sca = 0.0_dp do n = 1 , nb dn = real ( n , dp ) q_sca = q_sca + ( 2.0_dp * dn + 1.0_dp ) * ( abs ( mie_coeff_a ( n )) * abs ( mie_coeff_a ( n )) + abs ( mie_coeff_b ( n )) * abs ( mie_coeff_b ( n ))) q_ext = q_ext + ( 2.0_dp * dn + 1.0_dp ) * real ( mie_coeff_a ( n ) + mie_coeff_b ( n ), dp ) end do q_sca = q_sca * ( 2.0_dp / x ** 2 ) q_ext = q_ext * ( 2.0_dp / x ** 2 ) q_abs = q_ext - q_sca end subroutine calcMieEfficiencies !! Calculate and return the asymmetry parameter !! See Bohren&Huffman, page 120, for details on the equation subroutine calcAsymmetryParameter ( nb , q_sca , x , mie_coeff_a , mie_coeff_b , g ) implicit none integer , intent ( in ) :: nb real ( dp ), intent ( in ) :: q_sca , x complex ( dp ), dimension ( nb + 1 ), intent ( in ) :: mie_coeff_a , mie_coeff_b real ( dp ), intent ( out ) :: g integer :: n real ( dp ) :: dn g = 0.0_dp do n = 1 , nb - 1 dn = real ( n , dp ) g = g + dn * ( dn + 2.0_dp ) / ( dn + 1.0_dp ) * real ( mie_coeff_a ( n ) * conjg ( mie_coeff_a ( n + 1 )) + & & mie_coeff_b ( n ) * conjg ( mie_coeff_b ( n + 1 )), dp ) + & & ( 2.0_dp * dn + 1.0_dp ) / ( dn * ( dn + 1.0_dp )) * real ( mie_coeff_b ( n ) * conjg ( mie_coeff_b ( n )), dp ) end do g = g * ( 4.0_dp / ( x ** 2 * q_sca )) end subroutine calcAsymmetryParameter !! Calculate the starting value of A_N via the method of continued fractions by Lentz (1976) !! Convergence is reached if two consecutive terms differ by less than \"continued_fraction_epsilon\" !! Returns A_N !! This is the version for a complex A_N complex ( dp ) function startingANcontinuedFractions ( nb , mx ) implicit none integer , intent ( in ) :: nb complex ( dp ), intent ( in ) :: mx integer :: i real ( dp ) :: nu , con complex ( dp ) :: a_i complex ( dp ) :: function_numerator , function_denominator complex ( dp ) :: a_numerator , a_denominator nu = real ( nb , dp ) + 0.5_dp !! starting values function_numerator = cmplx ( 1.0_dp , 1.0_dp , dp ) function_denominator = cmplx ( 1.0_dp , 1.0_dp , dp ) !! n = 1 a_numerator = an ( 1 , nu , mx ) a_denominator = 1.0_dp function_numerator = function_numerator * a_numerator function_denominator = function_denominator * a_denominator !! n = 2 a_numerator = an ( 2 , nu , mx ) + 1.0_dp / a_numerator a_denominator = an ( 2 , nu , mx ) function_numerator = function_numerator * a_numerator function_denominator = function_denominator * a_denominator do i = 3 , cf_max_terms a_i = an ( i , nu , mx ) a_numerator = a_i + 1.0_dp / a_numerator a_denominator = a_i + 1.0_dp / a_denominator function_numerator = function_numerator * a_numerator function_denominator = function_denominator * a_denominator con = abs (( abs ( a_numerator ) - abs ( a_denominator )) / abs ( a_numerator )) if ( con < cf_epsilon ) then exit end if end do startingANcontinuedFractions = function_numerator / function_denominator & & - real ( nb , dp ) / mx end function startingANcontinuedFractions !! Calculate the starting value of A_N via the method of continued fractions by Lentz (1976) !! Convergence is reached if two consecutive terms differ by less than \"continued_fraction_epsilon\" !! Returns A_N !! This is the version for a real A_N real ( dp ) function startingANcontinuedFractionsReal ( nb , x ) implicit none integer , intent ( in ) :: nb real ( dp ), intent ( in ) :: x integer :: i real ( dp ) :: nu , con , a_i real ( dp ) :: function_numerator , function_denominator real ( dp ) :: a_numerator , a_denominator nu = real ( nb , dp ) + 0.5_dp !! starting values function_numerator = 1.0_dp function_denominator = 1.0_dp !! n = 1 a_numerator = anReal ( 1 , nu , x ) a_denominator = 1.0_dp function_numerator = function_numerator * a_numerator function_denominator = function_denominator * a_denominator !! n = 2 a_numerator = anReal ( 2 , nu , x ) + 1.0_dp / a_numerator a_denominator = anReal ( 2 , nu , x ) function_numerator = function_numerator * a_numerator function_denominator = function_denominator * a_denominator do i = 3 , cf_max_terms a_i = anReal ( i , nu , x ) a_numerator = a_i + 1.0_dp / a_numerator a_denominator = a_i + 1.0_dp / a_denominator function_numerator = function_numerator * a_numerator function_denominator = function_denominator * a_denominator con = abs (( a_numerator - a_denominator ) / a_numerator ) if ( con < cf_epsilon ) then exit end if end do startingANcontinuedFractionsReal = function_numerator / function_denominator & & - real ( nb , dp ) / x end function startingANcontinuedFractionsReal !! Calculates single terms a_n used in the evaluation of the continued fractions by Lentz (1976) !! See Eq. 9 in Lentz (1976) !! This is the version for a complex a_n complex ( dp ) function an ( n , nu , z ) implicit none integer , intent ( in ) :: n real ( dp ), intent ( in ) :: nu complex ( dp ), intent ( in ) :: z if ( mod ( n , 2 ) == 0 ) then an = - 1.0_dp * 2.0_dp * ( nu + real ( n , dp ) - 1.0_dp ) * 1.0_dp / z else an = 2.0_dp * ( nu + real ( n , dp ) - 1.0_dp ) * 1.0_dp / z end if end function an !! Calculates single terms a_n used in the evaluation of the continued fractions by Lentz (1976) !! See Eq. 9 in Lentz (1976) !! This is the version for a real-numbered a_n real ( dp ) function anReal ( n , nu , z ) implicit none integer , intent ( in ) :: n real ( dp ), intent ( in ) :: nu real ( dp ), intent ( in ) :: z if ( mod ( n , 2 ) == 0 ) then anReal = - 1.0_dp * 2.0_dp * ( nu + real ( n , dp ) - 1.0_dp ) * 1.0_dp / z else anReal = 2.0_dp * ( nu + real ( n , dp ) - 1.0_dp ) * 1.0_dp / z end if end function anReal end module lxmie_mod","tags":"","loc":"sourcefile/lxmie_mod.f90.html"},{"title":"Rosseland_data_mod.f90 – Rosseland Clouds","text":"Source Code module Rosseland_data_mod use , intrinsic :: iso_fortran_env implicit none integer , parameter :: dp = REAL64 real ( dp ), parameter :: pi = 4.0_dp * atan ( 1.0_dp ) real ( dp ), parameter :: twopi = 2.0_dp * pi real ( dp ), parameter :: hp = 6.62607015e-27_dp ! erg s - Planck's constant real ( dp ), parameter :: c_s = 2.99792458e10_dp ! cm s&#94;-1 - Vacuum speed of light real ( dp ), parameter :: kb = 1.380649e-16_dp ! erg K&#94;-1 - Boltzmann's constant integer :: nwl , na , nT real ( dp ), allocatable , dimension (:) :: a , T , wl logical :: c_flag integer :: nlines real ( dp ), allocatable , dimension (:) :: wl_ori , n_ori , k_ori , n_int , k_int contains subroutine Planck_mean ( nwl , wl , temp , Vl , Vr ) implicit none integer , intent ( in ) :: nwl real ( dp ), dimension ( nwl ), intent ( in ) :: wl , Vl real ( dp ), intent ( in ) :: temp real ( dp ), intent ( out ) :: Vr integer :: l real ( dp ) :: top , bot , left , right , xx real ( dp ), dimension ( nwl ) :: B , wl_cm !! Subroutine calculates the Planck mean weighted value !! Returns Planck mean to all array values do l = 1 , nwl wl_cm ( l ) = wl ( l ) * 1e-4_dp left = ( 2.0_dp * hp * c_s ** 2 ) / wl_cm ( l ) ** 5 xx = ( hp * c_s ) / ( wl_cm ( l ) * kb * temp ) xx = min ( xx , 3 5.0_dp ) ! Avoid overfloating right = 1.0_dp / ( exp ( xx ) - 1.0_dp ) B ( l ) = left * right end do top = trapz ( wl_cm (:),( Vl (:) * B (:))) bot = trapz ( wl_cm (:), B (:)) Vr = top / bot end subroutine Planck_mean subroutine Ross_mean ( nwl , wl , temp , Vl , Vr ) implicit none integer , intent ( in ) :: nwl real ( dp ), dimension ( nwl ), intent ( in ) :: wl , Vl real ( dp ), intent ( in ) :: temp real ( dp ), intent ( out ) :: Vr integer :: l real ( dp ) :: top , bot , xx , expx real ( dp ), dimension ( nwl ) :: dBdT , wl_cm !! Subroutine calculates Rosseland mean weighted value !! Returns Rosseland mean to all array values do l = 1 , nwl wl_cm ( l ) = wl ( l ) * 1e-4_dp xx = ( hp * c_s ) / ( wl_cm ( l ) * kb * temp ) xx = min ( xx , 3 5.0_dp ) ! Avoid overfloating expx = exp ( xx ) top = 2.0_dp * hp ** 2 * c_s ** 3 * expx bot = wl_cm ( l ) ** 6 * kb * temp ** 2 * ( expx - 1.0_dp ) ** 2 dBdT ( l ) = top / bot end do top = trapz ( wl_cm (:),( 1.0_dp / Vl (:)) * dBdT (:)) bot = trapz ( wl_cm (:), dBdT (:)) Vr = 1.0_dp / ( top / bot ) end subroutine Ross_mean subroutine read_RT_table ( RT_path ) implicit none character ( len = 100 ), intent ( in ) :: RT_path integer :: uRT print * , 'Reading: ' , trim ( RT_path ) open ( newunit = uRT , file = trim ( RT_path ), action = 'read' ) read ( uRT , * ) na , nT allocate ( a ( na ), T ( nT )) read ( uRT , * ) a (:) read ( uRT , * ) T (:) close ( uRT ) end subroutine read_RT_table subroutine read_nk_data ( nk_path ) implicit none character ( len = 100 ), intent ( in ) :: nk_path integer :: unk , n ! Read in n,k constants for species - Note comment out/in lines for 'MgSiO3_2' lines (Xianyu's original data) print * , 'Reading: ' , trim ( nk_path ) open ( newunit = unk , file = trim ( nk_path ), action = 'read' ) read ( unk , * ) nlines , c_flag allocate ( wl_ori ( nlines ), n_ori ( nlines ), k_ori ( nlines )) read ( unk , * ) ; read ( unk , * ); read ( unk , * ); read ( unk , * ) do n = 1 , nlines !do n = nlines, 1, -1 !'MgSiO3_2' - comment in/out read ( unk , * ) wl_ori ( n ), n_ori ( n ), k_ori ( n ) !wl_ori(n) = 1.0_dp/wl_ori(n) * 1e4 ! 'MgSiO3_2' - comment in/out n_ori ( n ) = max ( 0.0_dp , n_ori ( n )) k_ori ( n ) = max ( 0.0_dp , k_ori ( n )) !print*,  n, wl_ori(n),n_ori(n),k_ori(n) end do close ( unk ) end subroutine read_nk_data subroutine read_wavelength_table ( wl_path ) implicit none character ( len = 100 ), intent ( in ) :: wl_path integer :: uwl , l ! Read in wavelength grid print * , 'Reading: ' , trim ( wl_path ) open ( newunit = uwl , file = trim ( wl_path ), action = 'read' ) read ( uwl , * ) nwl allocate ( wl ( nwl )) do l = 1 , nwl read ( uwl , * ) wl ( l ) !print*, l, wl(l) end do close ( uwl ) end subroutine read_wavelength_table subroutine interp_nk () implicit none integer :: l , l1 real ( dp ) :: fac ! Interpolate n,k constants to wavelength grid allocate ( n_int ( nwl ), k_int ( nwl )) do l = 1 , nwl ! If required wavelength is less than availible data - keep constant if ( wl ( l ) < wl_ori ( 1 )) then n_int ( l ) = n_ori ( 1 ) k_int ( l ) = k_ori ( 1 ) n_int ( l ) = max ( n_int ( l ), 0.0_dp ) k_int ( l ) = max ( k_int ( l ), 0.0_dp ) ! If required wavelength is greater than availible data - extrapolate ! Non conducting: n is constant - k is linear decreasing ! Conducting: n and k are log-log extrapolated else if ( wl ( l ) > wl_ori ( nlines )) then if ( c_flag . eqv . . False .) then n_int ( l ) = n_ori ( nlines ) k_int ( l ) = k_ori ( nlines ) * wl_ori ( nlines ) / wl ( l ) n_int ( l ) = max ( n_int ( l ), 0.0_dp ) k_int ( l ) = max ( k_int ( l ), 0.0_dp ) else if ( c_flag . eqv . . True .) then do l1 = nlines , 1 , - 1 ! data can be noisy, so it's safer to use larger region to get the slope if ( wl_ori ( l1 ) < 0.7_dp * wl_ori ( nlines )) then exit end if enddo fac = log ( wl ( l ) / wl_ori ( nlines )) / log ( wl_ori ( l1 ) / wl_ori ( nlines )) n_int ( l ) = exp ( log ( n_ori ( nlines )) & & + fac * log ( n_ori ( l1 ) / n_ori ( nlines ))) k_int ( l ) = exp ( log ( k_ori ( nlines )) & & + fac * log ( k_ori ( l1 ) / k_ori ( nlines ))) n_int ( l ) = max ( n_int ( l ), 0.0_dp ) k_int ( l ) = max ( k_int ( l ), 0.0_dp ) end if ! Data is availible in the required wavelength range - log-log interpolation else ! Loop across work arrays untill straddle point is point then interpolate do l1 = 1 , nlines - 1 if ( wl ( l ) >= wl_ori ( l1 ) . and . wl ( l ) <= wl_ori ( l1 + 1 )) then fac = log ( wl ( l ) / wl_ori ( l1 )) / log ( wl_ori ( l1 + 1 ) / wl_ori ( l1 )) n_int ( l ) = exp ( log ( n_ori ( l1 )) & & + fac * log ( n_ori ( l1 + 1 ) / n_ori ( l1 ))) if ( k_ori ( l1 ) <= 0.0_dp . or . k_ori ( l1 + 1 ) <= 0.0_dp ) then k_int ( l ) = 0.0_dp else k_int ( l ) = exp ( log ( k_ori ( l1 )) & & + fac * log ( k_ori ( l1 + 1 ) / k_ori ( l1 ))) end if n_int ( l ) = max ( n_int ( l ), 0.0_dp ) k_int ( l ) = max ( k_int ( l ), 0.0_dp ) exit end if end do end if end do end subroutine interp_nk function trapz ( xx , yy ) result ( rr ) !! Calculates the integral of an array y with respect to x using the trapezoid !! approximation. Note that the mesh spacing of x does not have to be uniform. real ( dp ), intent ( in ) :: xx (:) !! Variable x real ( dp ), intent ( in ) :: yy ( size ( xx )) !! Function y(x) real ( dp ) :: rr !! Integral ∫y(x)·dx ! Integrate using the trapezoidal rule associate ( n => size ( xx )) rr = sum (( yy ( 1 + 1 : n - 0 ) + yy ( 1 + 0 : n - 1 )) * ( xx ( 1 + 1 : n - 0 ) - xx ( 1 + 0 : n - 1 ))) / 2.0_dp end associate end function trapz end module Rosseland_data_mod","tags":"","loc":"sourcefile/rosseland_data_mod.f90.html"},{"title":"Spectral_lognorm.f90 – Rosseland Clouds","text":"Source Code subroutine Spectral_lognorm ( sp , N0 , r_med , sigma , rmin , rmax , iint ) use Rosseland_data_mod use lxmie_mod , only : lxmie implicit none character ( len = 100 ), intent ( in ) :: sp integer , intent ( in ) :: iint real ( dp ), intent ( in ) :: N0 , r_med , sigma , rmin , rmax integer :: l , i , u_ln complex ( dp ) :: ri real ( dp ) :: lamin , lamax real ( dp ) :: x , xsec , q_ext , q_sca , q_abs , g real ( dp ), allocatable , dimension (:) :: kext_r , a_r , g_r , nd_r , r_r real ( dp ), allocatable , dimension (:) :: kext_l , a_l , g_l ! Perform Mie calculations allocate ( kext_l ( nwl ), a_l ( nwl ), g_l ( nwl )) !! allocate work arrays for each log-normal size allocate ( kext_r ( iint ), a_r ( iint ), g_r ( iint ), r_r ( iint ), nd_r ( iint )) !! Calculate sizes to integrate lognormal function from lamin = log10 ( rmin ) lamax = log10 ( rmax ) do i = 1 , iint r_r ( i ) = 1 0.0_dp ** (( lamax - lamin ) * real ( i - 1 , kind = dp ) / real ( iint - 1 , kind = dp ) + lamin ) !print*, i, r_r(i) end do do i = 1 , iint !! Number density assuming size r_r(i) at median size r_med nd_r ( i ) = N0 / ( r_r ( i ) * 1e-4_dp * sqrt ( 2.0_dp * pi ) * log ( sigma )) * & & exp ( - ( log ( r_r ( i ) / r_med ) ** 2 ) / ( 2.0_dp * log ( sigma ) ** 2 )) nd_r ( i ) = max ( nd_r ( i ), 1e-30_dp ) end do do l = 1 , nwl print * , l , nwl , real ( wl ( l )) ! Complex refractive index ri = cmplx ( n_int ( l ), - k_int ( l ), dp ) do i = 1 , iint ! Size parameter x = ( twopi * r_r ( i )) / wl ( l ) ! cross section xsec = pi * ( r_r ( i ) * 1e-4_dp ) ** 2 ! Call Mie routine for this size and wavelength call lxmie ( ri , x , q_ext , q_sca , q_abs , g ) kext_r ( i ) = xsec * q_ext * nd_r ( i ) a_r ( i ) = xsec * q_sca * nd_r ( i ) g_r ( i ) = max ( g , 1.0e-12_dp ) * xsec * q_sca * nd_r ( i ) end do !! Integrated normalised log-normal properties at wavelength l kext_l ( l ) = trapz ( r_r (:) * 1e-4_dp , kext_r (:)) a_l ( l ) = trapz ( r_r (:) * 1e-4_dp , a_r (:)) g_l ( l ) = trapz ( r_r (:) * 1e-4_dp , g_r (:)) !! Now calculate ssa and g ! g is scattering opacity weighted by g divided by scattering opacity g_l ( l ) = g_l ( l ) / a_l ( l ) ! ssa is scattering opacity divided by extinction opacity a_l ( l ) = a_l ( l ) / kext_l ( l ) end do ! Output table for each wavelanth open ( newunit = u_ln , file = 'results_Spectral_lognorm/' // trim ( sp ) // '_lognorm.txt' , action = 'readwrite' ) write ( u_ln , * ) r_med , sigma , rmin , rmax , iint , nwl do l = 1 , nwl write ( u_ln , * ) wl ( l ), kext_l ( l ), a_l ( l ), g_l ( l ) call flush ( u_ln ) end do close ( u_ln ) end subroutine Spectral_lognorm","tags":"","loc":"sourcefile/spectral_lognorm.f90.html"},{"title":"Planck_lognorm.f90 – Rosseland Clouds","text":"Source Code subroutine Planck_lognorm ( sp , N0 , sigma , rmin , rmax , iint ) use Rosseland_data_mod use lxmie_mod , only : lxmie implicit none character ( len = 100 ), intent ( in ) :: sp integer , intent ( in ) :: iint real ( dp ), intent ( in ) :: N0 , sigma , rmin , rmax integer :: i , aa , tt , l , u_k , u_a , u_g real ( dp ), dimension (:), allocatable :: kext_r , a_r , g_r , nd_r , r_r real ( dp ), dimension (:), allocatable :: kext_l , a_l , g_l real ( dp ), dimension (:, :), allocatable :: Pl_kext , Pl_a , Pl_g complex ( dp ) :: ri real ( dp ) :: x , xsec , q_ext , q_sca , q_abs , g real ( dp ) :: lamin , lamax !! Perform Mie calculations !! allocate work arrays for each log-normal size allocate ( kext_r ( iint ), a_r ( iint ), g_r ( iint ), r_r ( iint ), nd_r ( iint )) !! allocate work arrays for each wavelength allocate ( kext_l ( nwl ), a_l ( nwl ), g_l ( nwl )) !! allocate end Planck mean arrays allocate ( Pl_kext ( na , nT ), Pl_a ( na , nT ), Pl_g ( na , nT )) !! Calculate sizes to integrate lognormal function from lamin = log10 ( rmin ) lamax = log10 ( rmax ) do i = 1 , iint r_r ( i ) = 1 0.0_dp ** (( lamax - lamin ) * real ( i - 1 , kind = dp ) / real ( iint - 1 , kind = dp ) + lamin ) !print*, i, r_r(i) end do do aa = 1 , na print * , a ( aa ), aa , na do tt = 1 , nt do l = 1 , nwl ! Optical constant ri = cmplx ( n_int ( l ), - k_int ( l ), dp ) do i = 1 , iint !! Number density assuming size r_r(i) at median size a(aa) nd_r ( i ) = N0 / ( r_r ( i ) * 1e-4_dp * sqrt ( 2.0_dp * pi ) * log ( sigma )) * & & exp ( - ( log ( r_r ( i ) / ( a ( aa ))) ** 2 ) / ( 2.0_dp * log ( sigma ) ** 2 )) ! Limiter for underflow nd_r ( i ) = max ( nd_r ( i ), 1e-30_dp ) ! Cross section xsec = pi * ( r_r ( i ) * 1e-4_dp ) ** 2 ! Size parameter x = ( twopi * r_r ( i )) / wl ( l ) call lxmie ( ri , x , q_ext , q_sca , q_abs , g ) kext_r ( i ) = xsec * q_ext * nd_r ( i ) a_r ( i ) = xsec * q_sca * nd_r ( i ) g_r ( i ) = max ( g , 1.0e-12_dp ) * xsec * q_sca * nd_r ( i ) end do !! Integrated normalised log-normal properties at wavelength l kext_l ( l ) = trapz ( r_r (:) * 1e-4_dp , kext_r (:)) a_l ( l ) = trapz ( r_r (:) * 1e-4_dp , a_r (:)) g_l ( l ) = trapz ( r_r (:) * 1e-4_dp , g_r (:)) !print*, a(aa), wl(l), x, q_ext, q_sca, g end do call Planck_mean ( nwl , wl (:), T ( tt ), kext_l (:), Pl_kext ( aa , tt )) call Planck_mean ( nwl , wl (:), T ( tt ), a_l (:), Pl_a ( aa , tt )) call Planck_mean ( nwl , wl (:), T ( tt ), g_l (:), Pl_g ( aa , tt )) !! Now calculate ssa and g ! g is scattering opacity weighted by g divided by scattering opacity Pl_g ( aa , tt ) = Pl_g ( aa , tt ) / Pl_a ( aa , tt ) ! ssa is scattering opacity divided by extinction opacity Pl_a ( aa , tt ) = Pl_a ( aa , tt ) / Pl_kext ( aa , tt ) end do end do ! Output table - go radius outer loop, temperature inner loop ! Output cross section, ssa and g open ( newunit = u_k , file = 'results_Planck_lognorm/' // trim ( sp ) // '_kext.txt' , action = 'readwrite' ) write ( u_k , * ) na , nT , sigma write ( u_k , * ) a (:) write ( u_k , * ) T (:) do aa = 1 , na write ( u_k , * ) ( real ( Pl_kext ( aa , tt )), tt = 1 , nT ) call flush ( u_k ) end do close ( u_k ) open ( newunit = u_a , file = 'results_Planck_lognorm/' // trim ( sp ) // '_a.txt' , action = 'readwrite' ) write ( u_a , * ) na , nT , sigma write ( u_a , * ) a (:) write ( u_a , * ) T (:) do aa = 1 , na write ( u_a , * ) ( real ( Pl_a ( aa , tt )), tt = 1 , nT ) call flush ( u_a ) end do close ( u_a ) open ( newunit = u_g , file = 'results_Planck_lognorm/' // trim ( sp ) // '_g.txt' , action = 'readwrite' ) write ( u_g , * ) na , nT , sigma write ( u_g , * ) a (:) write ( u_g , * ) T (:) do aa = 1 , na write ( u_g , * ) ( real ( Pl_g ( aa , tt )), tt = 1 , nT ) call flush ( u_g ) end do close ( u_g ) end subroutine Planck_lognorm","tags":"","loc":"sourcefile/planck_lognorm.f90.html"}]}